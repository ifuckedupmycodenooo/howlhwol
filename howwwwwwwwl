
if getgenv().Loaded == true then
if Viper.Options.UpdateNotification == true then
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "discord.gg/Vipercc",
        Text = "Updated Script Settings.",
        Duration = 0.01,
    })
end
return
end

-- // Script Variables
local Script = { --// variables for the table, target etc
Table = getgenv().Viper.Combat,
Target = nil,
MainEvent = nil,
Functions = {},
Connections = {},
}

-- // intro Settings
if getgenv().Viper.Options.Intro then
local ImageIdfr = "http://www.roblox.com/asset/?id=82889871345333"

local Intro = {
    Intro = Instance.new("ScreenGui"),
    Anchored_Frame = Instance.new("Frame"),
    ImageLabel = Instance.new("ImageLabel")
}


function Tween(Object, Size1,Size2,Size3,Size4, Speed)
    Object:TweenSize(UDim2.new(Size1,Size2,Size3,Size4), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, Speed, true)
end


Intro.Intro.Name = "Intro"
Intro.Intro.Parent = game.CoreGui
Intro.Intro.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Intro.Anchored_Frame.Name = "Anchored_Frame"
Intro.Anchored_Frame.Parent = Intro.Intro
Intro.Anchored_Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Intro.Anchored_Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Intro.Anchored_Frame.BackgroundTransparency = 1.000
Intro.Anchored_Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
Intro.Anchored_Frame.Size = UDim2.new(0, 100, 0, 100)
Intro.ImageLabel.Parent = Intro.Anchored_Frame
Intro.ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
Intro.ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Intro.ImageLabel.BackgroundTransparency = 1.000
Intro.ImageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
Intro.ImageLabel.Size = UDim2.new(0, 0, 0, 0)
Intro.ImageLabel.Image = ImageIdfr
Intro.ImageLabel.ScaleType = Enum.ScaleType.Crop
local ImageLabel = game.CoreGui:FindFirstChild("Intro").Anchored_Frame.ImageLabel
local BlurEffect = Instance.new("BlurEffect", game.Lighting)
BlurEffect.Size = 0
for i = 0, 24, 1 do
    wait()
    BlurEffect.Size = i
end

Tween(ImageLabel, 0, 350, 0, 395, 0.8)
wait(2.2)
Tween(ImageLabel, 0, 0, 0, 0, 0.8)
for i = 24, 1, -1 do
    wait()
    BlurEffect.Size = i
end
wait(1)
Intro.Intro:Destroy()
BlurEffect:Destroy()
end

-- // Services
local Toggled = false -- Initialize Toggled
local players = game:GetService("Players")
local starterGui = game:GetService("StarterGui")
local replicatedStorage = game:GetService("ReplicatedStorage")
local inputService = game:GetService("UserInputService")
local virtualInputManager = game:GetService("VirtualInputManager")
local runService = game:GetService("RunService")

-- // Name Call
local Games = {
[2788229376]  = { Name = "Da Hood", Argument = "UpdateMousePosI2", Remote = "MainEvent" },
[16033173781] = {Name = "Da Hood Macro", Argument = "UpdateMousePosI2", Remote = "MainEvent"},
[7213786345]  = {Name = "Da Hood VC", Argument = "UpdateMousePosI2", Remote = "MainEvent"},
[9825515356]  = { Name = "Hood Customs", Argument = "MousePosUpdate", Remote = "MainEvent" },
[5602055394]  = { Name = "Hood Modded", Argument = "MousePos", Remote = "Bullets" },
[17403265390] = { Name = "Da Downhill", Argument = "MOUSE", Remote = "MAINEVENT" },
[18111448661] = { Name = "Da Uphill", Argument = "MOUSE", Remote = "MAINEVENT" },
[15186202290] = { Name = "Da Strike", Argument = "MOUSE", Remote = "MAINEVENT" },
[17344804827] = { Name = "Yeno Hood", Argument = "UpdateMousePos", Remote = "MainEvent" },
[17564718305] = { Name = "Da Nuketown", Argument = "MOUSE", Remote = "MAINEVENT" },
[11143225577] = { Name = "1v1 Hood Aim Trainer", Argument = "UpdateMousePos", Remote = "MainEvent" },
[17380542873] = { Name = "DA NUKE", Argument = "UpdateMousePos", Remote = "MainEvent" },
[17061444544] = { Name = "Rae Hood", Argument = "UpdateMousePos", Remote = "MainEvent" },
[14277620939] = { Name = "Custom FFA", Argument = "UpdateMousePos", Remote = "MainEvent" },
[9183932460]  = {Name = "Untitled Hood", Argument = "UpdateMousePos", Remote = ".gg/untitledhood"},
}

local mousePositionArgument = Games[game.PlaceId] or { Argument = "UpdateMousePos", Remote = "MainEvent" }

-- // Important Variables
local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera
local mainEvent = replicatedStorage:FindFirstChild(mousePositionArgument.Remote)

-- // Optimization Variables
local isA = game.IsA
local findFirstChild = game.FindFirstChild

local findPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList
local getChildren = workspace.GetChildren
local getPlayers = players.GetPlayers

local getMouseLocation = inputService.GetMouseLocation
local worldToViewportPoint = camera.WorldToViewportPoint

local fireServer = mainEvent.FireServer

local twait = task.wait
local tspawn = task.spawn

local tinsert = table.insert
local tfind = table.find

local newVector3 = Vector3.new
local newVector2 = Vector2.new
local newCFrame = CFrame.new
local fromAxisAngle = CFrame.fromAxisAngle

local newRay = Ray.new
local fromHSV = Color3.fromHSV

local min = math.min
local random = math.random
local abs = math.abs
local rad = math.rad
local sin = math.sin
local cos = math.cos
local inf = math.huge
local pi = math.pi

local upper = string.upper
local sub = string.sub

local freeFall = Enum.HumanoidStateType.Freefall
local jumping = Enum.HumanoidStateType.Jumping
local enumKeyCode = Enum.KeyCode

-- // Main Script Variables

-- Aimbot/Silent Variables
local isLocking, targetPlayer = false, nil

-- 360 Variables
local toggle360, totalRotation, fullCircleRotation = false, 0, 2 * pi

-- Macro Variable
local speedGlitching = false

-- // Script Functions


local isPlayerAlive = function(player: Player)
return (player.Character and findFirstChild(player.Character, "Humanoid"))
end

local wallCheck = function(character: Model)
if Viper.Misc.Checks.WallCheck ~= true then
    return true
end

local targetPosition = character.HumanoidRootPart.Position
local cameraPosition = camera.CFrame.Position
local distance = (targetPosition - cameraPosition).Magnitude

local hitPart, hitPosition = findPartOnRayWithIgnoreList(
    workspace,
    newRay(cameraPosition, (targetPosition - cameraPosition).Unit * distance),
    { localPlayer.Character, character }
)

return hitPart == nil or (hitPosition - cameraPosition).Magnitude >= distance
end

local velocityCheck = function(character: Model)
if not Viper.Misc.Checks.Resolver.Enabled == true then
    return false
end

local humanoidRootPart = character.HumanoidRootPart
local humanoid = character.Humanoid
local velocity = humanoidRootPart.Velocity
local yVelocity = abs(velocity.Y)

if (yVelocity > 5 and humanoid:GetState() ~= freeFall) or yVelocity > 35 or abs(velocity.X) > 35 or abs(velocity.Z) > 35 then
    return true
end

return false
end

local adjustPrediction = function(config: table, part: Instance)
if config.PredictionAdjuster ~= true then
    return config.Prediction
end

local prediction = config.Prediction
local velocity = part.Velocity
local max = Viper.PredictionAdjuster.VelocityThreshold

return prediction + ((prediction * 1.5) - prediction) * min(velocity.Magnitude / max, 1)
end

local getClosestPlayerToCursor = function(radius: number)
local shortestDistance = radius
local closestPlayer = nil
local mousePosition = getMouseLocation(inputService)
local part = Viper.Combat.Aimbot.Part

for _, player in next, getPlayers(players) do
    local character = player.Character

    if player ~= localPlayer and isPlayerAlive(player) and wallCheck(character) then
        local onScreenPosition, isOnScreen = worldToViewportPoint(camera, character[part].Position)
        local distance = (newVector2(onScreenPosition.X, onScreenPosition.Y) - mousePosition).Magnitude

        if distance < shortestDistance and isOnScreen == true then
            closestPlayer = player
            shortestDistance = distance
        end
    end
end
return closestPlayer
end

local getClosestPartFromPlayerToCursor = function(multipleParts: table, character: Model)
local shortestDistance = inf
local closestPart = nil
local mousePosition = getMouseLocation(inputService)
local parts = multipleParts.Parts
local indexAmount = 0

for _, part in next, getChildren(character) do
    if isA(part, "BasePart") and tfind(parts, part.Name) then
        local onScreenPosition = worldToViewportPoint(camera, part.Position)
        local distance = (newVector2(onScreenPosition.X, onScreenPosition.Y) - mousePosition).Magnitude

        if distance < shortestDistance then
            closestPart = part
            shortestDistance = distance
        end
        indexAmount = indexAmount + 1
    end

    if indexAmount >= #parts then
        break
    end
end
return closestPart
end

local resolvePartVelocity = function(part: Instance)
local lastPosition = part.Position
twait(0.145)
local currentPosition = part.Position

return (currentPosition - lastPosition) / 0.145
end

local getRandomVector3 = function(aimbot: table)
local positiveShakeAmount = aimbot.Shake.Amount
local negativeShakeAmount = -positiveShakeAmount
local factor = 0.01

return newVector3(
    random(-negativeShakeAmount, positiveShakeAmount) * factor,
    random(-negativeShakeAmount, positiveShakeAmount) * factor,
    random(-negativeShakeAmount, positiveShakeAmount) * factor
)
end





-- // Aimbot Main (Calculations and Camera Manipulation)

runService.Heartbeat:Connect(function(deltaTime: number)

local aimbot = Viper.Combat.Aimbot

if targetPlayer ~= nil and isLocking == true and targetPlayer.Character ~= nil then
    local character = targetPlayer.Character
    local isFalling = character.Humanoid:GetState() == freeFall
    local targetData = isFalling and aimbot.MouseTp or aimbot

    local targetPart
    if aimbot.MouseTp.Enabled and isFalling then
        targetPart = character[aimbot.MouseTp.Part]
    else
        targetPart = aimbot.MultipleParts.Enabled and getClosestPartFromPlayerToCursor(aimbot.MultipleParts, character) or character[aimbot.Part]
    end

    local alpha = targetData.Smoothness
    local prediction = adjustPrediction(targetData, targetPart)

    local goalPosition

    if not velocityCheck(character) then
        goalPosition = targetPart.Position + targetPart.Velocity * prediction
    else
        goalPosition = targetPart.Position + (resolvePartVelocity(targetPart) * prediction)
    end

    if aimbot.Shake.Enabled == true then
        goalPosition = goalPosition + getRandomVector3(aimbot)
    end

    local goal = newCFrame(camera.CFrame.Position, goalPosition)
    camera.CFrame = camera.CFrame:Lerp(goal, alpha)

    local checks = Viper.Misc.Checks

    if checks.KnockedChecks == true then
        local isKO = findFirstChild(character, "BodyEffects")["K.O"].Value
        local isGrabbed = findFirstChild(character, "GRABBING_CONSTRAINT") ~= nil
        if character.Humanoid.Health < 0.1 or isKO == true or isGrabbed == true then
            targetPlayer = nil
            isLocking = false
        end
    end

    if checks.TargetDeath == true and character.Humanoid.Health < 1 then
        targetPlayer = nil
        isLocking = false
    end

    if checks.PlayerDeath == true and localPlayer.Character.Humanoid.Health < 1 then
        targetPlayer = nil
        isLocking = false
    end
end
end)

-- // 360 Main

runService.RenderStepped:Connect(function(deltaTime: number) -- RenderStepped is better for this function :)
if toggle360 == true and Viper.Misc["360"].Enabled == true then
    local rotationIncrement = rad(Viper.Misc["360"].Speed * deltaTime)
    local remainingRotation = fullCircleRotation - totalRotation
    rotationIncrement = rotationIncrement > remainingRotation and remainingRotation or rotationIncrement

    local rotation = fromAxisAngle(newVector3(0, 1, 0), rotationIncrement)
    camera.CFrame = camera.CFrame * rotation
    totalRotation = totalRotation + rotationIncrement

    if totalRotation >= fullCircleRotation then
        toggle360 = false
        totalRotation = 0
    end
end
end)

-- // Silent Main
Script.Connections.FovOptimization = rs.RenderStepped:Connect(function()
blunt.Position = Vector2.new(mouse.X + insetX, mouse.Y + insetY)
end)

Script.Functions.NearestPlayer = function()
local closestPlayer
local shortestDistance = math.huge
local camera = game.Workspace.CurrentCamera
for _, player in pairs(game.Players:GetPlayers()) do
    pcall(function()
        if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            local primaryPart = player.Character.PrimaryPart
            if primaryPart then
                local direction = (primaryPart.Position - camera.CFrame.Position).Unit
                if camera.CFrame.LookVector:Dot(direction) > 0 then
                    local pos = camera:WorldToViewportPoint(primaryPart.Position)
                    local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
                    if magnitude < shortestDistance and magnitude <= blunt.Radius then
                        closestPlayer = player
                        shortestDistance = magnitude
                    end
                end
            end
        end
    end)
end
return closestPlayer
end




local player = game.Players.LocalPlayer
local Mouse = player:GetMouse()


Script.Functions.GetClosestPart = function(player)
local MaxDistance = math.huge
local ClosestPart = nil

for value, index in pairs(player.Character:GetChildren()) do
    if table.find({"Part", "MeshPart", "BasePart"}, index.ClassName) then
        local Position = workspace.CurrentCamera:WorldToScreenPoint(index.Position)
        local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(mouse.X, Mouse.Y)).Magnitude
        if Distance < MaxDistance then
            ClosestPart = index
            MaxDistance = Distance
        end
    end
end
return ClosestPart
end
Script.Functions.POS = function()
local silentSettings = getgenv().Viper and getgenv().Viper.Combat.Silent
local target

if not silentSettings then return end

if silentSettings.Type == "Fov" then
    target = Script.Functions.NearestPlayer
elseif silentSettings.Type == "Target" then
    target = Script.Target
end

if target and target.Character then
    local bodyEffects = target.Character:FindFirstChild("BodyEffects")
    local KOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
    local humanoid = target.Character:FindFirstChild("Humanoid")
    
    if getgenv().Viper.Misc.Checks and humanoid and (humanoid.Health <= 1 or KOd) then
        target = nil
    end

    local targetPart = target.Character:FindFirstChild(silentSettings.TargetParts)
    local airPart = target.Character:FindFirstChild(silentSettings.Air)

    if targetPart then
        local prediction = targetPart.Velocity * silentSettings.Prediction
        local position

        if target.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            targetPart = airPart
            position = targetPart.CFrame
        else
            position = targetPart.CFrame
        end

        if silentSettings.ClosestPart then
            local closest = Script.Functions.GetClosestPart(target)
            if closest then
                local endpoint = closest.Position + target.Character.HumanoidRootPart.Velocity * silentSettings.Prediction
                return CFrame.new(endpoint)
            end
        else
            local predictedPosition = position.Position + prediction
            return CFrame.new(predictedPosition)
        end
    end
end
end

if not string.find(identifyexecutor(), "Solara") and not string.find(identifyexecutor(), "Wave") and not string.find(identifyexecutor(), "Xeno") then
local grm = getrawmetatable(game)
local MousePosChanger2 = nil
setreadonly(grm, false)
MousePosChanger2 = grm.__index
grm.__index = function(self, Index)
    if not checkcaller() and self == Mouse then
        if Index == "Hit" then
            local EndPoint = Script.Functions.POS()
            if EndPoint then
                return EndPoint
            end
        elseif Index == "Target" then
            local EndPoint = Script.Functions.POS()
            if EndPoint then
                return EndPoint
            end
        end
    end
    return MousePosChanger2(self, Index)
end
end

-- // Keybinds

inputService.InputBegan:Connect(function(input: InputObject, gameProcessedEvent: boolean)
if gameProcessedEvent == true then
    return
end

local inputKeyCode = input.KeyCode
local keyBind = Viper.Options.Keybind

if inputKeyCode == enumKeyCode[sub(upper(keyBind.Aimbot), 1, 1)] then
    isLocking = not isLocking
    targetPlayer = isLocking and getClosestPlayerToCursor(inf) or nil
elseif inputKeyCode == enumKeyCode[sub(upper(keyBind.Resolver), 1, 1)] then
    local Resolver = Viper.Misc.Checks.Resolver

    Resolver.Enabled = not Resolver.Enabled
    if Resolver.Notification == true then
        starterGui:SetCore("SendNotification", {
            Title = "Resolver",
            Text = tostring(Resolver.Enabled),
            Duration = -inf,
        })
    end
elseif inputKeyCode == enumKeyCode[sub(upper(keyBind.Flip360), 1, 1)] then
    toggle360 = not toggle360
end
if Viper.Misc.Macro.Enabled == true then
    local macro = Viper.Misc.Macro

    if inputKeyCode == enumKeyCode[sub(upper(keyBind.Macro), 1, 1)] and macro.Type == "Third" then
        speedGlitching = not speedGlitching
        if speedGlitching == true then
            repeat
                local waittime = macro.Speed / 100
                twait(waittime)
                virtualInputManager:SendKeyEvent(true, "I", false, game)
                twait(waittime)
                virtualInputManager:SendKeyEvent(true, "O", false, game)
                twait(waittime)
                virtualInputManager:SendKeyEvent(true, "I", false, game)
                twait(waittime)
                virtualInputManager:SendKeyEvent(true, "O", false, game)
                twait(waittime)
            until not speedGlitching
        end
    elseif inputKeyCode == enumKeyCode[sub(upper(keyBind.Macro), 1, 1)] and macro.Type == "First" then
        speedGlitching = not speedGlitching
        if speedGlitching == true then
            repeat
                local waittime = macro.Speed / 100
                twait(waittime)
                virtualInputManager:SendMouseWheelEvent("0", "0", true, game)
                twait(waittime)
                virtualInputManager:SendMouseWheelEvent("0", "0", false, game)
                twait(waittime)
                virtualInputManager:SendMouseWheelEvent("0", "0", true, game)
                twait(waittime)
                virtualInputManager:SendMouseWheelEvent("0", "0", false, game)
                twait(waittime)
            until not speedGlitching
        end
    elseif inputKeyCode == enumKeyCode[sub(upper(keyBind.Macro), 1, 1)] and macro.Type == "Electron" then
        speedGlitching = not speedGlitching
        if speedGlitching == true then
            repeat
                runService.Heartbeat:Wait()
                keypress(0x49)
                runService.Heartbeat:Wait()
                keypress(0x4F)
                runService.Heartbeat:Wait()
                keyrelease(0x49)
                runService.Heartbeat:Wait()
                keyrelease(0x4F)
                runService.Heartbeat:Wait()
            until not speedGlitching
        end
    end
end
end)


local UserInputService = game:GetService("UserInputService")
local player = game.Players.LocalPlayer

-- Initialize character reference and update on respawn
local character = player.Character or player.CharacterAdded:Wait()

local function updateCharacter()
character = player.Character or player.CharacterAdded:Wait()
end

player.CharacterAdded:Connect(updateCharacter)

local proximityDistance = getgenv().Viper.Misc.Autobuy.ProximityDistance or 10

local targetPositions = {
Vector3.new(-635.77001953125, 18.855512619018555, -119.34500122070312),
Vector3.new(-1046.2003173828125, 18.851364135742188, -256.449951171875),
Vector3.new(492.8777160644531, 45.112525939941406, -620.4310913085938),
Vector3.new(533.6549682617188, 1.7305126190185547, -257.5400085449219),
Vector3.new(32.894508361816406, 22.60923194885254, -845.3250122070312)
}

-- Corresponding item names
local targetItems = {
"12 [Revolver Ammo] - $80",
"18 [Double-Barrel SG Ammo] - $64",
"20 [TacticalShotgun Ammo] - $64",
"12 [Revolver Ammo] - $53",
"18 [Double-Barrel SG Ammo] - $53"
}

local isLoopActive = false

local function checkProximityAndClick()
while isLoopActive do
    -- Recheck character and HumanoidRootPart to avoid errors after respawn
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        wait(0.1)  -- Small delay if HumanoidRootPart is not yet available after respawn
        continue
    end

    for index, targetPosition in ipairs(targetPositions) do
        local distance = (humanoidRootPart.Position - targetPosition).Magnitude

        if distance <= proximityDistance then
            local shopFolder = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop")
            
            if shopFolder then
                local targetItem = shopFolder:FindFirstChild(targetItems[index])
                
                if targetItem then
                    local clickDetector = targetItem:FindFirstChild("ClickDetector")
                    if clickDetector then
                        fireclickdetector(clickDetector)
                    end
                end
            end
            
            break
        end
    end

    wait(0.2)
end
end

-- Connect function to start buying when key is held
UserInputService.InputBegan:Connect(function(input, isProcessed)
if not isProcessed and input.UserInputType == Enum.UserInputType.Keyboard then
    local currentHoldKey = Enum.KeyCode[getgenv().Viper.Options.Keybind.AutoBuyKeyBind]
    
    if input.KeyCode == currentHoldKey then
        isLoopActive = true
        checkProximityAndClick()
    end
end
end)

-- Connect function to stop buying when key is released
UserInputService.InputEnded:Connect(function(input, isProcessed)
if not isProcessed and input.UserInputType == Enum.UserInputType.Keyboard then
    local currentHoldKey = Enum.KeyCode[getgenv().Viper.Options.Keybind.AutoBuyKeyBind]
    
    if input.KeyCode == currentHoldKey then
        isLoopActive = false
    end
end
end)

local function setAutobuyKeybind(key)
if Enum.KeyCode[key] then
    getgenv().Viper.Options.Keybind.AutoBuyKeyBind = key
end
end

-- // No Jump Cooldown (removed)


local player = game.Players.LocalPlayer
local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")

local isMoving = false
local speedMultiplier = getgenv().Viper.Cframe.Options.DefaultSpeed
local enable = getgenv().Viper.Cframe.Options.Enabled

local function moveCharacter(humanoidRootPart)
runService.Stepped:Connect(function()
    while isMoving do
        if not enable then
            isMoving = false
            break
        end
        local moveDirection = player.Character.Humanoid.MoveDirection
        if moveDirection.Magnitude > 0 then
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + (moveDirection * speedMultiplier * runService.RenderStepped:Wait())
        end
        wait()
    end
end)
end

local function initializeCharacter(character)
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

userInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.KeyCode.Name == getgenv().Viper.Cframe.Options.Keybinds.ToggleMovement then
        isMoving = not isMoving
        if isMoving then
            moveCharacter(humanoidRootPart)
        end
    end
end)

runService.RenderStepped:Connect(function()
    speedMultiplier = getgenv().Viper.Cframe.Options.DefaultSpeed
end)
end

if player.Character then
initializeCharacter(player.Character)
end

player.CharacterAdded:Connect(function(character)
initializeCharacter(character)
end)

game:GetService("RunService").Heartbeat:Connect(function()
enable = getgenv().Viper.Cframe.Options.Enabled
end)

getgenv().Loaded = true
